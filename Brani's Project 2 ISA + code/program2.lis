*memory
	One: ~hb~ 1
	Array_Index: ~hb~ 5
	Pointer: ~hb~ 4
	T: ~hb~ 19
	Num_Ones: ~hb~ 0
	Best_Match: ~hb~ 0
	Best_Match_Count: ~hb~ 1
	Last_Pattern_Index: ~hb~ 104
	Pattern_Array: ~hb~ 1

*instructions
	//Create the values in memory needed.
	INIT r0, 1
	INIT r1, 0
	SWD r0, [r1]
	INIT r0, 3
	ADDI r0, 2
	INIT r1, 1
	SWD r0, [r1]
	INIT r0, 3
	ADDI r0, 1
	INIT r1, [2]
	SWD r0, [r1]
	INIT r0, 1
	INIT r1, 2
	LWD r2, [r1]
	ADDI r2, 3
	SWD r0, [r1]

	INIT r0, 1
	LWD r2, [r0]

loop1:
	INIT r0, 3
	LWD r3, [r0]
	LWD r0, [r2]
	XOR r0, r3

	//Counts the number of bits in register 2.
	//The result is placed in r3.
	CNTR0
	//Load the "pointer" to the memory spot for Num_Ones
	//and place the count result there.
	INIT r0, 2
jumpBack5:
	JIF -6 //loop1
	LWD r2, [r0]
	SWD r3, [r2]

	INIT r0, 2
	LWD r2, [r0]
	ADDI r2, 1
	LWD r0, [r2]
jumpBack4:
	JIF -7 //jumpBack5
	
	//Is Num_Ones < Best_Match?
	SLE r0, r3
	JIF 4 //check
	//If not, then there is a new best match, we then
	//store it in the Best_Match place
	SWD r3, [r2]
	INIT r3, 1
	JIF 7 //skip1

check:
	ADDN
jumpBack3:
	JIF -7 //jumpBack4
	SLE r0, r3
	JIF  3 //skip2
	INIT r0, 0
	LWD r2, [r0]
skip1:
	JIF 6 //skip2
	ADDI r2, 1
jumpBack2:
	JIF -7 //jumpBack3
	LWD r3, [r2]
	ADDI r3, 1
	SWD r3, [r2]

skip2:
	INIT r0, 1
	LWD r2, [r0]
jumpBack1:
	JIF -6 //jumpBack2
	ADDI r2, 1
	INIT r0, 2
	LWD r3, [r0]
	ADDI r3, 3
	LWD r3, [r3]
	SLER r2, r3
	JIF -7 //jumpBack1

	HLT

